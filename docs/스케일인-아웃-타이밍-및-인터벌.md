# 스케일인/아웃 타이밍 및 인터벌 가이드

**작성일**: 2025-12-11  
**프로젝트**: VM-Autoscaling

---

## 📋 목차
1. [스케일아웃 타이밍](#스케일아웃-타이밍)
2. [스케일인 타이밍](#스케일인-타이밍)
3. [쿨다운 메커니즘](#쿨다운-메커니즘)
4. [Alertmanager 인터벌](#alertmanager-인터벌)
5. [최대 VM 개수 제한](#최대-vm-개수-제한)
6. [전체 프로세스 타임라인](#전체-프로세스-타임라인)

---

## 스케일아웃 타이밍

### 1. Alert 발생 조건

**스케일아웃 Alert Rule**:
- CPU 사용률 > 임계값 (기본: 80%) **또는** Memory 사용률 > 임계값 (기본: 80%)
- 조건이 `for` 기간 동안 지속되어야 Alert 발생 (기본: 1분)

**Alert Rule 예시**:
```promql
max(100 - (avg by (instance) (rate(node_cpu_seconds_total{mode="idle",job="auto-vm-test"}[5m])) * 100)) > 80
OR
max((1 - (avg by (instance) (node_memory_MemAvailable_bytes{job="auto-vm-test"}) / avg by (instance) (node_memory_MemTotal_bytes{job="auto-vm-test"}))) * 100) > 80
```

### 2. 스케일아웃 프로세스 순서 및 소요 시간

```
T0: Alert 발생 (Prometheus)
  └─ Alertmanager로 전송
  └─ Alertmanager → 백엔드 Webhook 호출

T0 + 1초: 백엔드 Webhook 처리
  ├─ 쿨다운 체크 (쿨다운 중이면 차단)
  ├─ 최대 VM 개수 체크 (Prometheus Job 등록 개수 기준)
  └─ Jenkins Job 트리거

T0 + 2초: Jenkins 파이프라인 시작
  ├─ Stage 1: Alert 파싱 (~1초)
  ├─ Stage 2: 오토스케일링 설정 조회 (~2초)
  ├─ Stage 3: IP 주소 할당 (~10초, ping 테스트)
  ├─ Stage 4: VM Clone (~1-2분)
  │   ├─ VM Clone (전원 꺼진 상태)
  │   ├─ VM Customization (고정 IP 설정)
  │   └─ VM 전원 켜기 및 IP 확인 (~20초~5분)
  ├─ Stage 5: F5 Pool Member 추가 (~5-10초) ✅ 서비스 투입 시점
  └─ Stage 6: 결과 요약 (~1초)

T0 + 2-8분: VM 생성 완료
  └─ Jenkins → 백엔드 Webhook 전송 (/api/webhook/jenkins/vm-created)
  └─ 백엔드 처리:
      ├─ Prometheus Job에 target 추가 (~5초)
      └─ 쿨다운 시작 (5분 = 300초)

T0 + 2-8분 + 5분: 쿨다운 종료
  └─ 다음 스케일아웃 가능
```

**총 소요 시간**: 약 2-8분 (VM 부팅 시간에 따라 다름)

### 3. 서비스 투입 시점

**서비스 투입**: F5 Pool Member 추가 완료 시점
- F5 L4 로드밸런서가 트래픽을 새 VM으로 분산 시작
- Prometheus 등록은 모니터링용이며 서비스 투입과는 별개

---

## 스케일인 타이밍

### 1. Alert 발생 조건

**스케일인 Alert Rule**:
- **모든 서버**의 CPU 사용률 < 임계값 (기본: 30%) **그리고** Memory 사용률 < 임계값 (기본: 30%)
- 조건이 `for` 기간 동안 지속되어야 Alert 발생 (기본: 5분)

**Alert Rule 예시**:
```promql
max(100 - (avg by (instance) (rate(node_cpu_seconds_total{mode="idle",job="auto-vm-test"}[5m])) * 100)) < 30
AND
max((1 - (avg by (instance) (node_memory_MemAvailable_bytes{job="auto-vm-test"}) / avg by (instance) (node_memory_MemTotal_bytes{job="auto-vm-test"}))) * 100) < 30
```

**중요**: `max()` 함수 사용으로 **모든 서버**가 임계값 이하여야 스케일인 발생

### 2. 스케일인 프로세스 순서 및 소요 시간

```
T0: Alert 발생 (Prometheus)
  └─ Alertmanager로 전송
  └─ Alertmanager → 백엔드 Webhook 호출

T0 + 1초: 백엔드 Webhook 처리
  ├─ 쿨다운 체크 (쿨다운 중이면 차단)
  ├─ 최소 VM 개수 체크 (Prometheus Job 등록 개수 기준)
  └─ Jenkins Job 트리거

T0 + 2초: Jenkins 파이프라인 시작
  ├─ Stage 1: Alert 파싱 (~1초)
  ├─ Stage 2: 오토스케일링 설정 조회 (~2초)
  ├─ Stage 3: Prometheus에서 VM IP 목록 조회 (~2초)
  ├─ Stage 4: 제거할 VM 선택 (~5초)
  │   ├─ 타임스탬프 있는 VM 우선 (스케일아웃 생성)
  │   └─ LIFO 정렬 (최신 VM부터)
  ├─ Stage 5: F5 Pool Member 제거 (~5초)
  │   └─ F5 Node 삭제 (~5초)
  ├─ Stage 6: Prometheus target 제거 (~5초)
  │   └─ 제거 확인 (~5초)
  └─ Stage 7: vCenter에서 VM 삭제 (~30초)
      ├─ VM 전원 종료 (~10초)
      └─ VM 삭제 (~20초)

T0 + 1-2분: VM 삭제 완료
  └─ Jenkins → 백엔드 Webhook 전송 (/api/webhook/jenkins/vm-deleted)
  └─ 백엔드 처리:
      ├─ Prometheus Job에서 target 제거 확인 (~5초)
      └─ 쿨다운 시작 (5분 = 300초)

T0 + 1-2분 + 5분: 쿨다운 종료
  └─ 다음 스케일인 가능
```

**총 소요 시간**: 약 1-2분

---

## 쿨다운 메커니즘

### 1. 쿨다운 목적

- **반복 스케일링 방지**: 짧은 시간 내 반복적인 스케일아웃/인 방지
- **리소스 안정화**: 새로 생성/삭제된 VM이 안정화될 시간 확보
- **비용 최적화**: 불필요한 스케일링 작업 감소

### 2. 쿨다운 기간

**기본값**: 5분 (300초)

**설정 위치**: 오토스케일링 설정 → `scaling.cooldownPeriod`

**쿨다운 시작 시점**:
- 스케일아웃 완료 후 (VM 생성 완료 webhook 수신 시)
- 스케일인 완료 후 (VM 삭제 완료 webhook 수신 시)
- 최대 VM 개수 도달 시 (스케일아웃 차단 시)
- 최소 VM 개수 도달 시 (스케일인 차단 시)

### 3. 쿨다운 동작 방식

```
스케일아웃 완료
  └─ 쿨다운 시작 (5분)
  └─ 쿨다운 중:
      ├─ 같은 서비스의 스케일아웃 요청 차단
      └─ "쿨다운 중입니다. X초 후에 다시 시도하세요." 응답

쿨다운 종료 (5분 후)
  └─ 다음 스케일아웃 가능
```

**쿨다운 상태 저장**: 파일 기반 (`backend/data/cooldown.json`)

### 4. 쿨다운 체크 로직

```javascript
// 백엔드 Webhook 핸들러에서
const cooldownStatus = await checkCooldown(serviceName, scaleAction);
if (cooldownStatus.inCooldown) {
  // 스케일링 요청 차단
  return {
    success: false,
    message: `쿨다운 중입니다. ${cooldownStatus.remainingTime}초 후에 다시 시도하세요.`
  };
}
```

---

## Alertmanager 인터벌

### 1. repeat_interval

**설정값**: 5분 (기존: 12시간)

**의미**: Alert가 해결되지 않으면 5분마다 재전송

**설정 위치**: `backend/src/services/alertmanagerService.js`

```yaml
route:
  repeat_interval: '5m'  # 12h → 5m로 단축
```

### 2. repeat_interval과 쿨다운의 관계

```
T0: 스케일아웃 완료, 쿨다운 시작 (5분)
T0 + 5분: 쿨다운 종료
T0 + 5분: Alertmanager의 repeat_interval에 의해 Alert 재전송
  └─ 쿨다운 종료 직후 즉시 스케일아웃 가능
```

**최적화**: 쿨다운 기간(5분)과 repeat_interval(5분)이 일치하여 쿨다운 종료 직후 즉시 다음 스케일아웃 가능

### 3. group_interval

**설정값**: 10초

**의미**: 같은 그룹의 Alert를 10초마다 그룹화하여 전송

### 4. group_wait

**설정값**: 10초

**의미**: 같은 그룹의 Alert를 10초 동안 대기 후 전송

---

## 최대 VM 개수 제한

### 1. 체크 기준

**Prometheus Job에 등록된 VM 개수**를 기준으로 체크

**이유**:
- Prometheus Job 등록 개수 = 실제 운영 중인 VM 개수
- VM 생성 시 Prometheus에 자동 등록되므로 항상 일치
- 명확하고 단순한 로직

### 2. 체크 시점

**스케일아웃 요청 시**:
1. Prometheus Job 조회
2. 현재 등록된 VM 개수 확인
3. 최대 VM 개수와 비교
4. 도달 시 쿨다운 시작 및 스케일아웃 차단

### 3. 체크 로직

```javascript
// 백엔드 Webhook 핸들러에서
const prometheusJobName = config.monitoring?.prometheusJobName;
const { getPrometheusTargets } = require('./services/prometheusMonitoringService');
const targetsResult = await getPrometheusTargets(prometheusJobName);

const currentVmCount = targetsResult.targets?.length || 0;
const maxVms = config.scaling?.maxVms || 10;

if (currentVmCount >= maxVms) {
  // 쿨다운 시작
  await startCooldown(serviceName, 'scale-out', cooldownPeriod);
  
  // 스케일아웃 차단
  return {
    success: false,
    message: `최대 VM 개수(${maxVms})에 도달하여 스케일아웃할 수 없습니다. (현재 Prometheus Job 등록 개수: ${currentVmCount}개)`
  };
}
```

### 4. 예시

**시나리오**:
- 최대 VM 개수: 4개
- 현재 Prometheus Job 등록 개수: 4개
- 결과: 스케일아웃 차단 ✅

**시나리오**:
- 최대 VM 개수: 4개
- 현재 Prometheus Job 등록 개수: 3개
- 결과: 스케일아웃 진행 ✅

### 5. IP Pool 부족 문제

**이전 로직**: IP Pool 범위 계산하여 부족 시 차단

**현재 로직**: IP Pool 부족 체크 제거
- IP Pool 범위는 사용자가 설정에서 확장 가능
- Prometheus Job 등록 개수 기준으로만 체크

**권장사항**: IP Pool 범위를 최대 VM 개수 이상으로 설정

---

## 전체 프로세스 타임라인

### 스케일아웃 시나리오

```
초기 상태: 2대 VM (1번, 2번 서버)

T0: 1번 서버 CPU 90% → Alert 발생
T0 + 1초: 백엔드 Webhook 처리
  ├─ 쿨다운 체크: 통과
  ├─ 최대 VM 개수 체크: 2 < 4 → 통과
  └─ Jenkins 트리거

T0 + 2분: 3번 VM 생성 시작
T0 + 2-8분: 3번 VM 생성 완료
  ├─ F5 Pool Member 추가 → 서비스 투입 ✅
  ├─ Prometheus Job에 target 추가
  └─ 쿨다운 시작 (5분)

T0 + 2-8분 + 5분: 쿨다운 종료
  └─ 1번 서버가 여전히 90% CPU 사용 중

T0 + 2-8분 + 5분: Alertmanager의 repeat_interval에 의해 Alert 재전송
  └─ 백엔드 Webhook 처리
      ├─ 쿨다운 체크: 통과 (쿨다운 종료)
      ├─ 최대 VM 개수 체크: 3 < 4 → 통과
      └─ Jenkins 트리거 → 4번 VM 생성 시작

T0 + 2-8분 + 5분 + 2-8분: 4번 VM 생성 완료
  ├─ F5 Pool Member 추가 → 서비스 투입 ✅
  ├─ Prometheus Job에 target 추가 (현재: 4개)
  └─ 쿨다운 시작 (5분)

T0 + 2-8분 + 5분 + 2-8분 + 5분: 쿨다운 종료
  └─ Alertmanager의 repeat_interval에 의해 Alert 재전송
      └─ 백엔드 Webhook 처리
          ├─ 쿨다운 체크: 통과
          ├─ 최대 VM 개수 체크: 4 >= 4 → 차단 ❌
          └─ 쿨다운 시작 (5분) → 스케일아웃 차단
```

### 스케일인 시나리오

```
초기 상태: 4대 VM (1번, 2번, 3번, 4번 서버)

T0: 모든 서버 CPU < 30% (5분 이상 지속) → Alert 발생
T0 + 1초: 백엔드 Webhook 처리
  ├─ 쿨다운 체크: 통과
  ├─ 최소 VM 개수 체크: 4 > 2 → 통과
  └─ Jenkins 트리거

T0 + 1-2분: VM 삭제 완료
  ├─ VM 선택: 4번 VM (최신, 타임스탬프 있음)
  ├─ F5 Pool Member 제거
  ├─ Prometheus target 제거 (현재: 3개)
  └─ 쿨다운 시작 (5분)

T0 + 1-2분 + 5분: 쿨다운 종료
  └─ 모든 서버가 여전히 < 30% CPU 사용 중

T0 + 1-2분 + 5분: Alertmanager의 repeat_interval에 의해 Alert 재전송
  └─ 백엔드 Webhook 처리
      ├─ 쿨다운 체크: 통과
      ├─ 최소 VM 개수 체크: 3 > 2 → 통과
      └─ Jenkins 트리거 → 3번 VM 삭제 시작

T0 + 1-2분 + 5분 + 1-2분: 3번 VM 삭제 완료
  ├─ Prometheus target 제거 (현재: 2개)
  └─ 쿨다운 시작 (5분)

T0 + 1-2분 + 5분 + 1-2분 + 5분: 쿨다운 종료
  └─ Alertmanager의 repeat_interval에 의해 Alert 재전송
      └─ 백엔드 Webhook 처리
          ├─ 쿨다운 체크: 통과
          ├─ 최소 VM 개수 체크: 2 <= 2 → 차단 ❌
          └─ 스케일인 차단
```

---

## 설정 가능한 값

### 오토스케일링 설정

```json
{
  "scaling": {
    "minVms": 2,              // 최소 VM 개수
    "maxVms": 4,              // 최대 VM 개수
    "scaleOutStep": 1,        // 스케일아웃 단계 (한 번에 생성할 VM 수)
    "scaleInStep": 1,         // 스케일인 단계 (한 번에 삭제할 VM 수)
    "cooldownPeriod": 300     // 쿨다운 기간 (초, 기본: 5분)
  },
  "monitoring": {
    "scaleOutCpuThreshold": 80,      // 스케일아웃 CPU 임계값 (%)
    "scaleOutMemoryThreshold": 80,   // 스케일아웃 Memory 임계값 (%)
    "scaleOutDuration": 1,           // 스케일아웃 Alert 지속 시간 (분)
    "scaleInCpuThreshold": 30,       // 스케일인 CPU 임계값 (%)
    "scaleInMemoryThreshold": 30,    // 스케일인 Memory 임계값 (%)
    "scaleInDuration": 5             // 스케일인 Alert 지속 시간 (분)
  }
}
```

### Alertmanager 설정

```yaml
route:
  group_by: ['alertname', 'cluster', 'service']
  group_wait: '10s'
  group_interval: '10s'
  repeat_interval: '5m'  # Alert 재전송 간격
  receiver: 'default-webhook'
```

---

## 주의사항

### 1. 쿨다운 기간과 repeat_interval

- 쿨다운 기간과 repeat_interval을 일치시키는 것을 권장
- 쿨다운 종료 직후 즉시 다음 스케일링 가능

### 2. 최대 VM 개수 설정

- IP Pool 범위를 최대 VM 개수 이상으로 설정 권장
- IP Pool 부족 시 VM 생성 실패 가능

### 3. 스케일인 Alert 지속 시간

- 스케일인 Alert는 `scaleInDuration` 동안 지속되어야 발생
- 너무 짧게 설정하면 불필요한 스케일인 발생 가능

### 4. VM 선택 로직

- 스케일인 시 타임스탬프 있는 VM(스케일아웃 생성) 우선 삭제
- 최초 생성 VM은 보호됨

---

## 요약

### 스케일아웃
- **Alert 지속 시간**: 1분
- **프로세스 소요 시간**: 2-8분
- **서비스 투입 시점**: F5 Pool Member 추가 완료
- **쿨다운 기간**: 5분
- **다음 스케일아웃 가능**: 쿨다운 종료 후 (약 7-13분 후)

### 스케일인
- **Alert 지속 시간**: 5분
- **프로세스 소요 시간**: 1-2분
- **쿨다운 기간**: 5분
- **다음 스케일인 가능**: 쿨다운 종료 후 (약 6-7분 후)

### 최대 VM 개수 제한
- **체크 기준**: Prometheus Job에 등록된 VM 개수
- **체크 시점**: 스케일아웃 요청 시
- **차단 시**: 쿨다운 시작하여 반복 시도 방지

---

---

## 접근 권한 및 향후 계획

### 현재 상태
- **접근 권한**: 관리자만 접근 가능
- **인증/인가**: 현재 단일 관리자 계정으로 운영
- **데이터 분리**: 고객별 데이터 분리 없음

### 향후 고도화 계획
- **고객별 분리 접근**: 고객별로 독립적인 접근 및 설정 관리
- **멀티 테넌시**: 고객별 데이터 격리 및 권한 관리
- **자체 관리**: 고객이 직접 오토스케일링 설정 및 모니터링 가능
- **인증/인가 강화**: 고객별 계정 관리 및 권한 제어

---

**작성자**: AI Assistant  
**최종 수정일**: 2025-12-11

