# 스케일인(Scale In) 구축 계획

## 개요

현재 스케일아웃(Scale Out) 기능이 완료되었으므로, 이제 스케일인(Scale In) 기능을 구축합니다.
스케일인은 리소스 사용률이 낮을 때 불필요한 VM을 제거하여 비용을 절감하는 기능입니다.

## 현재 구조 분석

### 스케일아웃 흐름
1. **Prometheus Alert Rule**: CPU/Memory 임계치 초과 시 Alert 발생
2. **Alertmanager**: Alert를 Jenkins로 Webhook 전송
3. **Jenkins 파이프라인**: VM 생성 → F5 Pool에 추가 → Node Exporter/Promtail 설치

### 스케일인에 필요한 변경사항
1. 스케일인 조건 설정 추가
2. 스케일인 Alert Rule 생성
3. Alertmanager 라우팅 규칙 추가
4. Jenkins 파이프라인 수정 (VM 삭제 로직)
5. 최소 VM 수 보호 로직

## 구현 계획

### 1단계: 설정 구조 확장

#### 1.1 프론트엔드 설정 화면 수정
**파일**: `frontend/src/components/AutoscalingConfigForm.jsx`

**추가할 필드:**
```javascript
monitoring: {
  cpuThreshold: 80,           // 스케일아웃 CPU 임계값 (기존)
  memoryThreshold: 80,         // 스케일아웃 Memory 임계값 (기존)
  duration: 5,                 // 스케일아웃 지속 시간 (기존)
  prometheusJobName: '',
  
  // 스케일인 조건 추가
  scaleInCpuThreshold: 30,    // 스케일인 CPU 임계값 (새로 추가)
  scaleInMemoryThreshold: 30,  // 스케일인 Memory 임계값 (새로 추가)
  scaleInDuration: 10          // 스케일인 지속 시간 (새로 추가, 스케일아웃보다 길게)
}
```

**UI 추가:**
- 모니터링 설정 섹션에 "스케일인 조건" 추가
- 스케일인 CPU/Memory 임계값 입력 필드
- 스케일인 지속 시간 입력 필드
- 스케일인 조건 설명 박스 (스케일아웃 조건과 유사)

#### 1.2 백엔드 설정 검증 수정
**파일**: `backend/src/services/autoscalingService.js`

**추가할 검증:**
- `scaleInCpuThreshold`는 `cpuThreshold`보다 낮아야 함
- `scaleInMemoryThreshold`는 `memoryThreshold`보다 낮아야 함
- `scaleInDuration`은 `duration`보다 길어야 함 (안정성을 위해)

### 2단계: Prometheus Alert Rule 생성

#### 2.1 스케일인 Alert Rule 추가
**파일**: `backend/src/services/prometheusAlertService.js`

**추가할 함수:**
```javascript
async function createScaleInAlertRule(config) {
  // 스케일인 조건:
  // - 모든 서버의 CPU/Memory 사용률이 임계치 이하
  // - min() 함수 사용 (모든 서버가 낮아야 함)
  // - 지속 시간은 스케일아웃보다 길게 설정
}
```

**Alert Rule 로직:**
```promql
# 스케일인 조건: 모든 서버의 사용률이 임계치 이하
(
  min(100 - (avg by (instance) (rate(node_cpu_seconds_total{mode="idle",job="${prometheusJobName}"}[5m])) * 100)) < ${scaleInCpuThreshold}
  AND
  min((1 - (avg by (instance) (node_memory_MemAvailable_bytes{job="${prometheusJobName}"}) / avg by (instance) (node_memory_MemTotal_bytes{job="${prometheusJobName}"}))) * 100) < ${scaleInMemoryThreshold}
)
```

**차이점:**
- 스케일아웃: `max()` 사용 (한 대라도 높으면)
- 스케일인: `min()` 사용 (모든 서버가 낮아야 함)
- AND 조건 사용 (CPU와 Memory 모두 낮아야 함)

#### 2.2 Alert Rule 수정
**파일**: `backend/src/services/prometheusAlertService.js`

**수정할 함수:**
- `createAlertRule()` → `createScaleOutAlertRule()`로 이름 변경
- `createScaleInAlertRule()` 추가
- `createAlertRule()`에서 두 Alert Rule 모두 생성하도록 수정

### 3단계: Alertmanager 라우팅 규칙

#### 3.1 스케일인 라우팅 규칙 추가
**파일**: `backend/src/services/alertmanagerService.js`

**추가할 라우팅 (공통 파이프라인 방식):**
```yaml
routes:
  - match:
      service: ${serviceName}
      alertname: ${serviceName}_HighResourceUsage  # 스케일아웃 Alert
    receiver: 'jenkins-webhook-plg-autoscale-out'
    continue: false
  - match:
      service: ${serviceName}
      alertname: ${serviceName}_LowResourceUsage  # 스케일인 Alert
    receiver: 'jenkins-webhook-plg-autoscale-in'
    continue: false
```

**Webhook 설정 (공통 파이프라인):**
- 스케일아웃: `http://jenkins:8080/generic-webhook-trigger/invoke?token=plg-autoscale-token`
- 스케일인: `http://jenkins:8080/generic-webhook-trigger/invoke?token=plg-autoscale-in-token`
- 모든 서비스가 동일한 공통 파이프라인 사용

### 4단계: Jenkins 파이프라인 생성

#### 4.1 스케일인 전용 파이프라인 생성
**파일**: `jenkins/Jenkinsfile.autoscale-in` (새로 생성)

**구조:**
- 스케일아웃과 완전히 분리된 독립적인 파이프라인
- 스케일인 전용 로직만 포함

**주요 단계:**
1. 현재 VM 목록 조회 (Prometheus Job에서)
2. 최소 VM 수 확인 (`minVms`)
3. VM 선택 (가장 오래된 VM 또는 리소스 사용률이 가장 낮은 VM)
4. F5 Pool에서 제거
5. Node Exporter/Promtail 삭제
6. Prometheus Job에서 target 제거
7. vCenter에서 VM 삭제

#### 4.2 Jenkins Job 생성
**파일**: `backend/src/services/jenkinsService.js`

**추가할 함수:**
```javascript
async function createScaleInJenkinsJob(config) {
  // 스케일인 전용 Jenkins Job 생성
  // Job 이름: plg-autoscale-in (공통 파이프라인)
  // Jenkinsfile: jenkins/Jenkinsfile.autoscale-in
}
```

**Job 이름 규칙 (공통 파이프라인 방식):**
- 스케일아웃: `plg-autoscale-out` (기존 공통 파이프라인 사용, 생성하지 않음)
- 스케일인: `plg-autoscale-in` (공통 파이프라인, 최초 생성 시에만 생성)

### 5단계: 프론트엔드 UI 개선

#### 5.1 스케일인 조건 표시
**파일**: `frontend/src/components/AutoscalingConfigForm.jsx`

**추가할 섹션:**
- 스케일인 조건 설명 박스 (스케일아웃 조건과 유사)
- 스케일인 조건:
  - 모든 서버의 CPU/Memory 사용률이 임계치 이하
  - 지속 시간 동안 유지
  - 최소 VM 수 보호

#### 5.2 스케일인 이벤트 표시
**파일**: `frontend/src/components/ScaleOutEvents.jsx` (또는 새 컴포넌트)

**추가할 기능:**
- 스케일인 이벤트 목록 표시
- 스케일아웃/스케일인 구분 표시
- 삭제된 VM 정보 표시

## 구현 완료 내역

### ✅ Phase 1: 기본 구조 (완료)
- 프론트엔드 설정 화면에 스케일인 조건 추가
- 백엔드 설정 검증 로직 추가
- 스케일인 Alert Rule 생성 로직 구현
- Alertmanager 라우팅 규칙 추가

### ✅ Phase 2: Jenkins 파이프라인 (완료)
- Jenkinsfile.autoscale-in 생성
- remove-f5-pool-member.py 스크립트 생성
- 스케일인 Jenkins Job 생성 로직 구현 (공통 파이프라인 방식)
- 공통 파이프라인 방식으로 변경:
  - 스케일아웃: `plg-autoscale-out` 사용 (기존 파이프라인, 생성하지 않음)
  - 스케일인: `plg-autoscale-in` 생성 (공통 파이프라인)

### ✅ Jenkins 서버 접속 정보 확인 (완료)
- Jenkins 서버 IP: 10.255.0.103
- SSH 사용자: jenkins
- PEM Key: /home/ubuntu/workspace/vm-autoscaling/pemkey/jenkins
- Jenkins 서버 환경: Python3, govc, curl, Git 모두 설치됨

### ✅ 공통 파이프라인 방식으로 변경 (완료)
- 서비스별 파이프라인 생성 방식에서 공통 파이프라인 방식으로 변경
- 스케일아웃: 기존 `plg-autoscale-out` 사용 (생성하지 않음)
- 스케일인: `plg-autoscale-in` 공통 파이프라인 생성
- Alertmanager 라우팅도 공통 파이프라인 webhook 사용
- 설정 삭제 시 공통 파이프라인은 삭제하지 않음

## 구현 순서

### Phase 1: 기본 구조 (1-2일) ✅ 완료
1. ✅ 설정 구조 확장 (프론트엔드 + 백엔드)
2. ✅ 스케일인 Alert Rule 생성 로직
3. ✅ Alertmanager 라우팅 규칙 추가

### Phase 2: Jenkins 파이프라인 (2-3일)
4. ✅ Jenkinsfile.autoscale-in 생성 (스케일인 전용)
5. ✅ 스케일인 Jenkins Job 생성 로직
6. ✅ VM 선택 로직 구현
7. ✅ F5 Pool에서 제거 로직
8. ✅ VM 삭제 로직
9. ✅ Prometheus Job에서 target 제거

### Phase 3: 안정화 및 테스트 (1-2일)
10. ✅ 최소 VM 수 보호 로직 테스트
11. ✅ 스케일인/스케일아웃 충돌 방지 로직
12. ✅ Cooldown Period 적용
13. ✅ 에러 처리 및 롤백 로직

## 주요 고려사항

### 1. 스케일인 조건 설계
- **모든 서버가 낮아야 함**: `min()` 함수 사용
- **AND 조건**: CPU와 Memory 모두 낮아야 함
- **더 긴 지속 시간**: 스케일아웃보다 길게 설정 (예: 10분)
- **이유**: 일시적인 부하 감소로 인한 불필요한 스케일인 방지

### 2. VM 선택 전략
**추천: 가장 오래된 VM 삭제**
- 구현이 간단함
- 예측 가능함
- 새 VM이 더 최신 설정을 가질 가능성

**대안: 리소스 사용률이 가장 낮은 VM**
- 더 정교하지만 구현 복잡
- Prometheus에서 추가 쿼리 필요

### 3. 최소 VM 수 보호
- `minVms` 설정값 확인
- 현재 VM 개수가 `minVms` 이하면 스케일인 중단
- Alert Rule에서도 체크 가능 (하지만 Jenkins에서도 체크하는 것이 안전)

### 4. Cooldown Period
- 스케일아웃 후 일정 시간 동안 스케일인 방지
- 스케일인 후 일정 시간 동안 스케일아웃 방지
- `cooldownPeriod` 설정 활용

### 5. 안전장치
- VM 삭제 전 확인 절차
- F5에서 제거 후 트래픽 종료 대기 시간
- 삭제 실패 시 롤백 로직
- 로그 및 이벤트 기록

## 파이프라인 분리 방식 (공통 파이프라인)

### 구조
```
jenkins/
  ├── Jenkinsfile.autoscale      (스케일아웃 전용 - 기존, plg-autoscale-out에서 사용)
  └── Jenkinsfile.autoscale-in  (스케일인 전용 - 신규, plg-autoscale-in에서 사용)
```

### Jenkins Job (공통 파이프라인)
- **스케일아웃**: `plg-autoscale-out` (모든 서비스 공통 사용)
- **스케일인**: `plg-autoscale-in` (모든 서비스 공통 사용)

### Alertmanager 라우팅
- 스케일아웃 Alert → `plg-autoscale-out` Job (공통 webhook)
- 스케일인 Alert → `plg-autoscale-in` Job (공통 webhook)
- 각 서비스별로 `service` 라벨로 구분하여 라우팅

### 장점
✅ 각 파이프라인이 단순하고 명확
✅ 안전성 (실수로 잘못된 액션 실행 불가능)
✅ 독립적인 수정 및 디버깅 가능
✅ 유지보수 용이
✅ **공통 파이프라인 사용으로 관리 용이**: 서비스별로 파이프라인을 생성하지 않고 공통 파이프라인 사용
✅ **리소스 절약**: 서비스가 많아져도 파이프라인은 2개만 유지

### 동작 방식
1. **설정 생성 시**: `plg-autoscale-in` 파이프라인이 없으면 생성 (최초 1회만)
2. **Alert 발생 시**: Alertmanager가 `service` 라벨을 확인하여 공통 파이프라인으로 라우팅
3. **파이프라인 실행**: 파이프라인 내에서 webhook 파라미터로 서비스 정보를 받아 처리
4. **설정 삭제 시**: 공통 파이프라인은 삭제하지 않음 (다른 서비스에서도 사용)

## 예상 작업 시간

- **Phase 1**: 1-2일
- **Phase 2**: 2-3일
- **Phase 3**: 1-2일
- **총 예상 시간**: 4-7일

## 다음 단계

1. Phase 1부터 시작하여 기본 구조 확장
2. 각 단계별로 테스트 진행
3. 문제 발생 시 즉시 수정

## 참고사항

- 스케일인은 스케일아웃보다 더 신중하게 설계해야 함
- 불필요한 VM 삭제로 인한 서비스 중단 방지가 최우선
- 최소 VM 수 보호는 필수
- Cooldown Period를 충분히 설정하여 불안정한 스케일링 방지
- **두 개의 파이프라인으로 분리**: 안전성과 가독성을 위해 스케일아웃과 스케일인을 완전히 분리
