# 스케일인(Scale In) 구축 계획

## 개요

현재 스케일아웃(Scale Out) 기능이 완료되었으므로, 이제 스케일인(Scale In) 기능을 구축합니다.
스케일인은 리소스 사용률이 낮을 때 불필요한 VM을 제거하여 비용을 절감하는 기능입니다.

## 현재 구조 분석

### 스케일아웃 흐름
1. **Prometheus Alert Rule**: CPU/Memory 임계치 초과 시 Alert 발생
2. **Alertmanager**: Alert를 Jenkins로 Webhook 전송
3. **Jenkins 파이프라인**: VM 생성 → F5 Pool에 추가 → Node Exporter/Promtail 설치

### 스케일인에 필요한 변경사항
1. 스케일인 조건 설정 추가
2. 스케일인 Alert Rule 생성
3. Alertmanager 라우팅 규칙 추가
4. Jenkins 파이프라인 수정 (VM 삭제 로직)
5. 최소 VM 수 보호 로직

## 구현 계획

### 1단계: 설정 구조 확장

#### 1.1 프론트엔드 설정 화면 수정
**파일**: `frontend/src/components/AutoscalingConfigForm.jsx`

**추가할 필드:**
```javascript
monitoring: {
  cpuThreshold: 80,           // 스케일아웃 CPU 임계값 (기존)
  memoryThreshold: 80,         // 스케일아웃 Memory 임계값 (기존)
  duration: 5,                 // 스케일아웃 지속 시간 (기존)
  prometheusJobName: '',
  
  // 스케일인 조건 추가
  scaleInCpuThreshold: 30,    // 스케일인 CPU 임계값 (새로 추가)
  scaleInMemoryThreshold: 30,  // 스케일인 Memory 임계값 (새로 추가)
  scaleInDuration: 10          // 스케일인 지속 시간 (새로 추가, 스케일아웃보다 길게)
}
```

**UI 추가:**
- 모니터링 설정 섹션에 "스케일인 조건" 추가
- 스케일인 CPU/Memory 임계값 입력 필드
- 스케일인 지속 시간 입력 필드
- 스케일인 조건 설명 박스 (스케일아웃 조건과 유사)

#### 1.2 백엔드 설정 검증 수정
**파일**: `backend/src/services/autoscalingService.js`

**추가할 검증:**
- `scaleInCpuThreshold`는 `cpuThreshold`보다 낮아야 함
- `scaleInMemoryThreshold`는 `memoryThreshold`보다 낮아야 함
- `scaleInDuration`은 `duration`보다 길어야 함 (안정성을 위해)

### 2단계: Prometheus Alert Rule 생성

#### 2.1 스케일인 Alert Rule 추가
**파일**: `backend/src/services/prometheusAlertService.js`

**추가할 함수:**
```javascript
async function createScaleInAlertRule(config) {
  // 스케일인 조건:
  // - 모든 서버의 CPU/Memory 사용률이 임계치 이하
  // - min() 함수 사용 (모든 서버가 낮아야 함)
  // - 지속 시간은 스케일아웃보다 길게 설정
}
```

**Alert Rule 로직:**
```promql
# 스케일인 조건: 모든 서버의 사용률이 임계치 이하
(
  min(100 - (avg by (instance) (rate(node_cpu_seconds_total{mode="idle",job="${prometheusJobName}"}[5m])) * 100)) < ${scaleInCpuThreshold}
  AND
  min((1 - (avg by (instance) (node_memory_MemAvailable_bytes{job="${prometheusJobName}"}) / avg by (instance) (node_memory_MemTotal_bytes{job="${prometheusJobName}"}))) * 100) < ${scaleInMemoryThreshold}
)
```

**차이점:**
- 스케일아웃: `max()` 사용 (한 대라도 높으면)
- 스케일인: `min()` 사용 (모든 서버가 낮아야 함)
- AND 조건 사용 (CPU와 Memory 모두 낮아야 함)

#### 2.2 Alert Rule 수정
**파일**: `backend/src/services/prometheusAlertService.js`

**수정할 함수:**
- `createAlertRule()` → `createScaleOutAlertRule()`로 이름 변경
- `createScaleInAlertRule()` 추가
- `createAlertRule()`에서 두 Alert Rule 모두 생성하도록 수정

### 3단계: Alertmanager 라우팅 규칙

#### 3.1 스케일인 라우팅 규칙 추가
**파일**: `backend/src/services/alertmanagerService.js`

**추가할 라우팅:**
```yaml
routes:
  - match:
      alertname: ${serviceName}_LowResourceUsage  # 스케일인 Alert
    receiver: 'jenkins-scale-in'
    continue: false
```

**Webhook 설정:**
- 스케일인용 별도 webhook URL 또는 기존 webhook에 action 타입 추가

### 4단계: Jenkins 파이프라인 수정

#### 4.1 Jenkinsfile 수정
**파일**: `jenkins/Jenkinsfile.autoscale`

**추가할 로직:**
1. Alert 타입 확인 (스케일아웃 vs 스케일인)
2. 스케일인 시:
   - 현재 VM 개수 확인
   - 최소 VM 수(`minVms`) 확인
   - VM 개수가 `minVms`보다 많으면:
     - 가장 오래된 VM 선택 (또는 리소스 사용률이 가장 낮은 VM)
     - F5 Pool에서 제거
     - Node Exporter/Promtail 삭제
     - vCenter에서 VM 삭제
     - Prometheus Job에서 target 제거

**고려사항:**
- 어떤 VM을 삭제할지 결정하는 로직 필요
  - 옵션 1: 가장 오래된 VM (생성 시간 기준)
  - 옵션 2: 리소스 사용률이 가장 낮은 VM
  - 옵션 3: 라운드로빈 방식
- F5에서 제거 후 일정 시간 대기 (트래픽 종료 대기)
- VM 삭제 전 확인 절차

#### 4.2 Jenkins Job XML 수정
**파일**: `backend/src/services/jenkinsService.js`

**추가할 변수:**
- `SCALE_ACTION`: "scale-out" 또는 "scale-in"
- 스케일인 관련 설정 전달

### 5단계: 프론트엔드 UI 개선

#### 5.1 스케일인 조건 표시
**파일**: `frontend/src/components/AutoscalingConfigForm.jsx`

**추가할 섹션:**
- 스케일인 조건 설명 박스 (스케일아웃 조건과 유사)
- 스케일인 조건:
  - 모든 서버의 CPU/Memory 사용률이 임계치 이하
  - 지속 시간 동안 유지
  - 최소 VM 수 보호

#### 5.2 스케일인 이벤트 표시
**파일**: `frontend/src/components/ScaleOutEvents.jsx` (또는 새 컴포넌트)

**추가할 기능:**
- 스케일인 이벤트 목록 표시
- 스케일아웃/스케일인 구분 표시
- 삭제된 VM 정보 표시

## 구현 순서

### Phase 1: 기본 구조 (1-2일)
1. ✅ 설정 구조 확장 (프론트엔드 + 백엔드)
2. ✅ 스케일인 Alert Rule 생성 로직
3. ✅ Alertmanager 라우팅 규칙 추가

### Phase 2: Jenkins 파이프라인 (2-3일)
4. ✅ Jenkinsfile에 스케일인 로직 추가
5. ✅ VM 선택 로직 구현
6. ✅ F5 Pool에서 제거 로직
7. ✅ VM 삭제 로직
8. ✅ Prometheus Job에서 target 제거

### Phase 3: 안정화 및 테스트 (1-2일)
9. ✅ 최소 VM 수 보호 로직 테스트
10. ✅ 스케일인/스케일아웃 충돌 방지 로직
11. ✅ Cooldown Period 적용
12. ✅ 에러 처리 및 롤백 로직

## 주요 고려사항

### 1. 스케일인 조건 설계
- **모든 서버가 낮아야 함**: `min()` 함수 사용
- **AND 조건**: CPU와 Memory 모두 낮아야 함
- **더 긴 지속 시간**: 스케일아웃보다 길게 설정 (예: 10분)
- **이유**: 일시적인 부하 감소로 인한 불필요한 스케일인 방지

### 2. VM 선택 전략
**추천: 가장 오래된 VM 삭제**
- 구현이 간단함
- 예측 가능함
- 새 VM이 더 최신 설정을 가질 가능성

**대안: 리소스 사용률이 가장 낮은 VM**
- 더 정교하지만 구현 복잡
- Prometheus에서 추가 쿼리 필요

### 3. 최소 VM 수 보호
- `minVms` 설정값 확인
- 현재 VM 개수가 `minVms` 이하면 스케일인 중단
- Alert Rule에서도 체크 가능 (하지만 Jenkins에서도 체크하는 것이 안전)

### 4. Cooldown Period
- 스케일아웃 후 일정 시간 동안 스케일인 방지
- 스케일인 후 일정 시간 동안 스케일아웃 방지
- `cooldownPeriod` 설정 활용

### 5. 안전장치
- VM 삭제 전 확인 절차
- F5에서 제거 후 트래픽 종료 대기 시간
- 삭제 실패 시 롤백 로직
- 로그 및 이벤트 기록

## 예상 작업 시간

- **Phase 1**: 1-2일
- **Phase 2**: 2-3일
- **Phase 3**: 1-2일
- **총 예상 시간**: 4-7일

## 다음 단계

1. Phase 1부터 시작하여 기본 구조 확장
2. 각 단계별로 테스트 진행
3. 문제 발생 시 즉시 수정

## 참고사항

- 스케일인은 스케일아웃보다 더 신중하게 설계해야 함
- 불필요한 VM 삭제로 인한 서비스 중단 방지가 최우선
- 최소 VM 수 보호는 필수
- Cooldown Period를 충분히 설정하여 불안정한 스케일링 방지

